main :-
        write(a),
        _A = decimal,
        write(b),
        _B = range(end => _A,ground => _C,start => _A),
	write(c),
        cond(_A :== @,
             (write(x1),_A = residuation(instance,awake => [_D: singleton(_B)|@]),write(x2)),
             cond((write(u1),_A = residuation(instance,awake => _E), write(u2)),
		  (write(a1),add2list(_E,_D), write(a2)), succeed)),
	write(d),
        _C = not _A :== residuation,
	write(e),
        cond(_F :== @,_F = range(ground => false),succeed),
	write(e1),
        cond(_F .ground,
	     (_F .start = _B .start,
	      write(e2),
              _F .end = _B .end),
	     (_F = @(end => _G,ground => _H,start => _I),
	      write(f),
	      _I :== @,
	      _G :== @,
	      write(g),
	      _I = _B .start,
	      _G = _B .end,
	      _H <- _B .ground,
	      write(h),
	      cond(_I :\== residuation and _I :\== @,
		   (fd_awake_constraints(_F .chain_min),
		    write(i),
		    cond(_G :\== residuation and _G :\== @,(fd_awake_constraints(_F .chain_max),
							    write(j),
							    fd_awake_constraints(_F .chain_min_max)),succeed)),
		   cond(_G :\== residuation and _G :\== @,
			fd_awake_constraints(_F .chain_max),
			succeed)),
	      write(k),
	      propagate_constraints)),
        write(l),
        nl,
	write(_A),nl,
        fail.

decimal -> {0;1;2;3;4;5;6;7;8;9}.

propagate_constraints :-
	write(p).
